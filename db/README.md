# Database

This folder contains all the things required to use and maintain the database for Rider.

## Instructions

To begin, please install the packages in the repository:

```bash
pnpm i
```

Furthermore, you will need dotenvx to pass the environment variables into the migration tool. For MacOS, run the following command:

```bash
brew install dotenvx/brew/dotenvx
```

If you are running another OS or would prefer to install it another way, you can view the installation instructions [here](https://dotenvx.com/docs/install).

Next, you will need to install zapatos, but since

Finally, you should copy .env.example and rename it to .env and then populate the .env file.

For details on how to use graphile-migrate, view the repository [here](https://github.com/graphile/migrate). Or if you would like details on how to use Zapatos, click [here](https://jawj.github.io/zapatos)

## Migrations (graphile-migrate)

You want to write your current migration into the `current.sql` file you can find in the `/migrations` folder.

**[OPTIONAL]** Then, you can run the following command to test out your migration while you write with the following command:

```bash
pnpm run db:watch
```

This will check to see if your `current.sql` file is valid and can be applied to your database with no issues.

**You can choose not to run this command if you are sure that your SQL file has no issues. However, it is highly recommended you don't follow this path unless you know what you are doing.**

Once you are ready to commit your migration, use the following command:

```bash
pnpm run db:commit
```

This will push the SQL inside of `/migrations/current.sql` into the `/migrations/commited` directory.

Finally, to apply all unapplied migrations, simply run:

```bash
pnpm run db:migrate
```

## Models (Zapatos)

To automatically generate types based on the current database schema, run the following command:

```bash
pnpm run db:generate
```

These types will then be placed in `/models/schema.d.ts`. However, do not use these types inside of the production code. Instead, go to `/models/index.ts` and write abstracted types as needed. For example:

```ts
import type * as s from "zapatos/schema";

type User = s.User.Whereable;

export { User };
```

Find details on Zapatos [here](https://jawj.github.io/zapatos).

## Functions

These are not autogenerated, and are SQL commands written by the developer. Please try to follow the repository format, and group by model (for example: `/user/index.ts` for User operations).

For all functions, the first parameter should be an object for all the values that are required to complete the method. The second parameter should be the client that is of type `Sql` which is from the `postgres` library.

For example:

```ts
import { Sql } from "postgres";
import { User } from "../../models";

export async function findUserById(
  { userId }: { userId: string },
  client: Sql
) {
  const rs = await client<User[]>`
    SELECT
        *
    FROM
      "User"
    WHERE
      id=${userId}
`;

  return rs.length > 0 ? rs[0] : null;
}
```
